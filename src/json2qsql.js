import {singular} from './naming.js';
import {qsql_version} from './ddl.js';

var json2qsql = (function () {

    function indent( depth ) {
        var s = "";
        for (var i = 0; i < depth; i++)
            s = s + "   ";
        return s;
    }

    function hasEntry( array, entry ) {
        for( const i in array ) 
            if( JSON.stringify(array[i]) == JSON.stringify(entry) ) 
                return true;
        return false;
    }

    function getId( record ) {
        let suffixes = ["_id", "Id"];
        if( record['id'] != null )
            return {key: 'id', value: record['id']};
        let found = false;
        for( let i = 0; i < suffixes.length; i++ ) {
            const suffix = suffixes[i];
            for( let property in record ) {
                if( property.endsWith(suffix) ) {
                    return {key: property, value : record[property]};
                }       
            }
        }
    }

 
    function hasPrimitiveAttr( value ) {
        for( let property in value ) {
            if( value[property] != null && typeof value[property] == "object" ) 
                continue;
            return true;
        }
        return false;
    }

    function suggestName( obj ) {
        let property = null;
        outer: for( const i in obj ) {
            if( i == 0 )
                for( const attr in obj[i] ) {
                    property = attr;
                    break outer;
                }
            else {
                property = i;
                break outer;
            }
        }
        if( property.toLowerCase() == 'id' )
            return null;

        if( property.toLowerCase().endsWith('_id') )
            return property.substring(0,property.length-'_id'.length);
        if( property.endsWith('Id') )
            return property.substring(0,property.length-'Id'.length);

        return null;
    }

    function isM2M( content, attr1, attr2 ) {
        let is12M = false;
        let isM21 = false;
        for( const i in content )
            for( var j = 0; j < i; j++ ) {
                if( content[i][attr1] == content[j][attr1] 
                 && content[i][attr2] != content[j][attr2]
                ) is12M = true;
                else if( content[i][attr1] != content[j][attr1] 
                    && content[i][attr2] == content[j][attr2]
                ) isM21 = true;
                if( is12M && isM21 )  
                    return true;
            }
        return false;
    }

    function signature( obj ) {
        if( obj == null )
            return '';
        if( typeof obj != "object" )
            return '';
        let ret = '(';
        for( let property in obj ) {
            if( property == 0 )
                return signature( obj[property] );
             if( obj[property] != null && typeof obj[property] == "object" ) 
                continue;
           ret += property+',';
        }
        if( ret.lastIndexOf(',') == ret.length-1 )
            ret = ret.substring(0,ret.length-1);
        return ret+')';
    }

    function auxTabSignature( table1, table2 ) {
        let pos = table1.indexOf('(');
        if( 0 < pos )
            table1 = table1.substring(0, pos); 
        pos = table2.indexOf('(');
        if( 0 < pos )
            table2 = table2.substring(0, pos); 
        return table1+'_'+table2+'('+table1+'_id,'+table2+'_id)';
    }
    
    /*function isArray( obj ) {
        let cnt = 0;
        for( let property in obj ) {
            if( isNaN(property) )
                return false;
            cnt++;
        }
        return  0 < cnt;  
    }*/
    
    /**
     * @param {*} input JSON document
     * @param {*} name  optional file name, will be the tip attribute if none in JSON
     * @returns 
     */
    function translate( input, name ) {
        const obj = JSON.parse(input); 

        const sugg = suggestName(obj);
        if( sugg != null )
            name = sugg;
        if( name == null )
            name = 'root_tbl'

        const tc = new TableContent();
        tc.duplicatesAndParents(name+signature(obj), obj);
        tc.flatten(name+signature(obj), obj);

        let output = tc.output(name+signature(obj), obj, 0);

        //output += "\n\ndv "+name+"_dv "+name +"";
        output += '\n\n#settings = { genpk: false, drop: true }';

        output += '\n\n#flattened = \n';
        const tableContent = {};
        for( const tabSig in tc.tableContent )
            tableContent[tc.tableName(tabSig)] = tc.tableContent[tabSig];
        output += JSON.stringify(tableContent, null, 3);    
        output += '\n';  

        output += '\n\n-- Generated by json2qsql.js ' + `${ qsql_version() } ` + new Date().toLocaleString() +'\n\n';

        output += '#document = \n';
        output += JSON.stringify(obj, null, 3);    
        output += '\n';  

        return output;
    }

    function TableContent() {
       
        this.tableContent = {};        // e.g. {'batter(id,type)' -> [{"id":"1001","type":"Regular"},...],  ... }      
        this.notNormalized = [];       // e.g. ['batter(id,type)', 'topping(...)'] 
        this.tableSignatures = [];     // e.g. ['batter(id,type)', ]
        this.child2parent = {}         // e.g. {'batter(id,type)' -> 'donut(...)', ...

        this.objCounts = {};

        this.output = function( key, value, level, m2m ) {
            if( m2m != false && this.notNormalized.includes(key) ) {
                const auxTable = auxTabSignature(this.parent(key),key);
                const tContent = this.tableContent[auxTable];
                if( tContent != null ) {
                    let output = '\n'+indent(level)+this.tableName(auxTable)+" /insert "+tContent.length;
                    const record = tContent[0];
                    if( isM2M(tContent,this.refIdName(this.parent(key)), this.refIdName(key)) ) {  
                        output += this.output(key, value, level+1, false);
                        return output;
                    }
                }
            }

            let m2o = '';
            if( this.notNormalized.includes(key) )
                m2o = '>'
            let output = '\n'+indent(level)+m2o+this.tableName(key);

            if( typeof value == 'string' ) {
                //output += ' vc';
            }
            if( typeof value == 'number' ) {
                output += ' num';
                if( key.endsWith('_id') || key.endsWith('Id') ) {
                    output += ' /pk';
                    return output;
                }
            }
            if( 'id' == key ) {
                return '\n'+indent(level)+'id vc32 /pk';
            }
            tofinal: if( value != null && typeof value == "object" ) {
                if( Array.isArray(value) ) {
                    for( const property in value ) {
                        if( 1 <= property )
                            console.log('1 <= property !');
                        const field = value[property];
                        output = this.output(key, field, level, m2m);
                        break tofinal;
                    }
                } else {
                    if( key != "" ) {
                        if( this.tableContent[key] == null )
                            console.log();
                        //if( this.tableName(key) == 'threatened_species' )
                            //console.log();
                        output += '  /insert '+this.tableContent[key].length;
                    }
                }
                let promotedField = "";
                if( !this.tableSignatures.includes(key) ) {
                    output = '';
                    level--;
                }
                for( let property in value ) {
                    const field = value[property];
                    if( property != null  ) {
                        const fld = singular(key);
                        const cmp = property.toLowerCase();
                        if( key != null && fld + "_id" == cmp && 0 < level )
                            promotedField = property;
                        if( fld + "_id" == cmp )
                            continue;
                        if( !isNaN(property) && !Array.isArray(value) )
                            continue;
                    }
                    const subtree = this.output(property+signature(field), field, level + 1);
                    output += subtree;
                }
                if( promotedField != "" )
                    output += '\n'+indent(level)+ promotedField;
            } else {
                //output += '=' + value;
            }
            return output;
        }

        this.idSeq = 1;

        this.flatten = function( key, value, parentId ) {
            let record = {}
     
            for( let property in value ) {
                if( value[property] != null && typeof value[property] == "object" ) { 
                    let k = key;
                    let pId = parentId;
                    if( isNaN(property) ) {
                        k = property+signature(value[property]);
                        const tmp = getId(record);
                        if( tmp != null )
                            pId = tmp;
                    }
                    this.flatten( k, value[property], pId );
                } else {
                    record[property] = value[property];
                }
            }

            if( !this.notNormalized.includes(key) && parentId != null && Object.keys(record).length )
                record[parentId.key]=parentId.value;
    
            const hasKeys = 0 < Object.keys(record).length;
            let array = this.tableContent[key];
            if( hasKeys ) {
                if( array == null )
                    array = [];
                if( !hasEntry(array, record) ) {
                    array.push(record);
                }
                if( this.notNormalized.includes(key) ) {
                    const parent = this.parent(key);
                    if( parent != null ) {
                        const m2m = auxTabSignature(parent,key);
                        let array2 = this.tableContent[m2m];
                        if( array2 == null )
                            array2 = [];
                        const newObj = {};
                        newObj[this.refIdName(parent)] = parentId.value;
                        let id = getId(record);
                        if( id == null ) {
                            record['id'] = this.idSeq++;
                            id = getId(record);
                        }
                        newObj[this.refIdName(key)] = id.value;
                        array2.push(newObj);
                        this.tableContent[m2m] = array2;
                    }
                }
                this.tableContent[key] = array;
            } else if( array == null )
                this.tableContent[key] = [];
        }

        this.duplicatesAndParents = function ( attr, value ) {
            const key = '"'+attr+'":'+JSON.stringify(value);
            let tmp = this.objCounts[key];
            if( tmp == null )
                tmp = 0;

            let isComposite = false;
            for( let property in value ) {
                //if( property == '1' && typeof value[property] == "object" )
                    //console.log();
                    //if( property == 'adjustments' )
                        //console.log();
                    if( value[property] != null && typeof value[property] == "object" ) {  
                        let k = attr;
                        if( isNaN(property) ) 
                            k = property+signature(value[property]);
                        else if( !Array.isArray(value) ) {
                            continue;
                    }
                    if( k != attr )
                        this.child2parent[k] = attr;
                    this.duplicatesAndParents( k, value[property] );
                    isComposite = true;
                }
            }

            //if( attr == 'adjustments()' )
                //console.log();
            const hasPrimAttr = hasPrimitiveAttr(value);
            if( hasPrimAttr && !this.tableSignatures.includes(attr) )
                this.tableSignatures.push(attr);
            if( !isComposite ) {
                this.objCounts[key] = tmp + 1;                
            }     
            if( 1 < this.objCounts[key] && !this.notNormalized.includes(attr) )
                this.notNormalized.push(attr);
        }

        this.parent = function ( table ) {
            let ret = this.child2parent[table];
            if( ret != null && !this.tableSignatures.includes(ret) )
                return this.parent(ret);
            return ret; 
        }

        this.tableName = function ( tableSignature ) {
            const ip = tableSignature.indexOf('(');
            if( ip < 0 )
                return tableSignature;
            let table = tableSignature.substring(0,ip);
            let cnt = 0;
            let pos = -1;
            for( const property in this.tableSignatures ) {
                const cmp = this.tableSignatures[property];
                const cmpTable = cmp.substring(0,cmp.indexOf('('));
                if( cmpTable == table ) 
                    cnt++;
                if( cmp == tableSignature ) 
                    pos = cnt;
            }
            //if( !isNaN(parseInt(table)) )
                //table = 'num_'+table;
            if( cnt < 2 )
                return table;
            return table+pos; 
        }

        this.refIdName = function ( tableSignature ) {
            return singular(this.tableName(tableSignature))+'_id';
        }
    

    }

    return translate;
}());

export default json2qsql;